<!DOCTYPE html>
<html lang="en">
<head>
  <title>Origami</title>
  <meta charset="utf-8">
  <meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
  <style>
    body {
      overflow: hidden;
      border: 1px solid darkblue;
      margin: 10px;
    }
  </style>
</head>
<body>

<script type="module">

  import {Model} from "./src/Model.js";
  import {OrigamiObject} from "./src/OrigamiObject.js";
  import {OrbitControls} from "./libs/OrbitControls.module.js";
  import {
    Scene, PlaneBufferGeometry, BoxBufferGeometry, Color, PerspectiveCamera,
    AmbientLight, SpotLight, LightShadow, ShadowMaterial, CameraHelper,
    Mesh, GridHelper, MeshPhongMaterial,
    WebGLRenderer
  } from "./libs/three.module.js";
  import {GUI} from "./libs/dat.gui.module.js";

  let camera, scene, renderer, dirLight, hemiLight;
  let controls;

  let model, origamiObject;

  init();
  animate();

  function init() {

    camera = new PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
    camera.position.set(0, 0, 600);

    scene = new Scene();
    scene.background = new Color(0xb3c7e6);

    // CONTROL
    controls = new OrbitControls(camera);
    controls.maxPolarAngle = Math.PI;
    controls.enableZoom = true;
    controls.minDistance = 200;
    controls.maxDistance = 1000;

    // LIGHT
    scene.add(new AmbientLight(0x505050));

    const light = new SpotLight(0xffffff, 1.5);
    light.position.set(500, 500, 500);
    light.castShadow = true;
    light.shadow = new LightShadow(new PerspectiveCamera(60, 1, 200, 10000));
    light.shadow.bias = -0.00022;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;

    scene.add(light);

    // // Helper for shadow camera (optional)
    // let cameraHelper = new CameraHelper(light.shadow.camera);
    // scene.add(cameraHelper);

    // GROUND
    let planeGeometry = new PlaneBufferGeometry(2000, 2000);
    planeGeometry.rotateX(-Math.PI / 2);
    let planeMaterial = new ShadowMaterial({opacity: 0.2});
    let ground = new Mesh(planeGeometry, planeMaterial);
    ground.position.y = -200;
    ground.receiveShadow = true;
    scene.add(ground);

    // GROUND Grid
    let gridHelper = new GridHelper(2000, 100);
    gridHelper.position.y = -199;
    gridHelper.material.opacity = 0.25;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);

    // BOX
    let geometry = new BoxBufferGeometry(200, 200, 200);
    let material = new MeshPhongMaterial({
      color: 0xe3738c,
      specular: 0xffffff,
      shininess: 2,
      flatShading: true
    });
    let cube = new Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    // scene.add(cube);

    // ORIGAMI
    model = new Model();
    model.init([-200, -200, 200, -200, 200, 200, -200, 200]);
    model.splitCross(model.points[0], model.points[1]);
    model.rotate(model.segments[6], -45, [model.points[1], model.points[2]]);

    // Object Origami
    origamiObject = new OrigamiObject(model);
    scene.add(origamiObject);

    // Gui
    let params = {
      rotate_first: 180,
      rotate_second: 180,
      shadows: true,
      reset: function () {
        controls.reset();
      }
    };

    let gui = new GUI();
    gui.add(params, 'rotate_first', 0, 360).onChange(function (value) {
      controls.enabled = false; // needed to prevent orbit
      let angle = model.computeAngle(model.segments[6]);
      model.rotate(model.segments[6], (angle - value), [model.points[1], model.points[2]]);
      origamiObject.update();
    });
    gui.add(params, 'rotate_second', 0, 360).onChange(function (value) {
      controls.enabled = false; // needed to prevent orbit
      let angle = model.computeAngle(model.segments[6]);
      model.rotate(model.segments[6], (value - angle), [model.points[0], model.points[3]]);
      origamiObject.update();
    });
    // gui.add(params, 'shadows');
    gui.open();
    gui.add(params, 'reset');

    // RENDERER
    renderer = new WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    window.document.body.appendChild(renderer.domElement);
    renderer.shadowMap.enabled = true;

    // Resize
    window.addEventListener('resize', onWindowResize, false);
  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function animate() {
    requestAnimationFrame(animate);
    render();
    controls.enabled = true;
  }

  function render() {
    renderer.render(scene, camera);
  }

</script>
</body>
</html>
