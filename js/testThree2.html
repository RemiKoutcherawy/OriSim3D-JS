<!DOCTYPE html>
<html lang="en">
	<head>
		<title>testThree</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {font-family: Monospace;background-color: #f0f0f0;margin: 10px;overflow: hidden;}
		</style>
	</head>
	<body>

		<script src="three.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="SelectControls.js"></script>
    <script src="dat.gui.min.js"></script>
    <script src="stats.min.js"></script>
		<script>

			var container, stats;
			var camera, controls, scene, renderer, mesh;
			var anim = true;
			var objects = [];

			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
// Perspective
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 700;
// Controls
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 4.0;
// Scenes
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );
// Lights
//				scene.add( new THREE.AmbientLight( 0x404040 ) );
				var light = new THREE.DirectionalLight( 0xffffff, 0.8 ); // DirectionalLight SpotLight
				light.position.set( 0, 0, 2000 );
				light.castShadow = true;
// Shadows
				light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 200, 10000 ) );
				light.shadow.bias = - 0.0022;
				light.shadow.mapSize.width = 2048;
				light.shadow.mapSize.height = 2048;
				scene.add( light );
// Objects
        var pt = [{x:-200,y:-200,z:0},{x:200,y:-200,z:0},{x:200,y:200,z:0},{x:-200,y:200,z:0}];

// Points
        var geometryPoint  = new THREE.Geometry();
        var pt0 = new THREE.Vector3(pt[0].x, pt[0].y, pt[0].z);
        geometryPoint.vertices.push(pt0);
        var materialPoint = new THREE.PointsMaterial({size:20, color:0x0000ff});
        var point         = new THREE.Points(geometryPoint, materialPoint);
        scene.add(point);
        objects.push(point);

        geometryPoint  = new THREE.Geometry();
        var pt1 = new THREE.Vector3(pt[1].x, pt[1].y, pt[1].z);
        geometryPoint.vertices.push(pt1);
        materialPoint = new THREE.PointsMaterial({size:20, color:0x0000ff});
        point          = new THREE.Points(geometryPoint, materialPoint);
        scene.add(point);
        objects.push(point);

        geometryPoint  = new THREE.Geometry();
        var pt2 = new THREE.Vector3(pt[2].x, pt[2].y, pt[2].z);
        geometryPoint.vertices.push(pt2);
        materialPoint = new THREE.PointsMaterial({size:20, color:0x0000ff});
        point          = new THREE.Points(geometryPoint, materialPoint);
        scene.add(point);
        objects.push(point);

        geometryPoint  = new THREE.Geometry();
        var pt3 = new THREE.Vector3(pt[3].x, pt[3].y, pt[3].z);
        geometryPoint.vertices.push(pt3);
        materialPoint = new THREE.PointsMaterial({size:20, color:0x0000ff});
        point          = new THREE.Points(geometryPoint, materialPoint);
        scene.add(point);
        objects.push(point);

// Lines
        var geometryline = new THREE.Geometry();
        geometryline.vertices.push(pt0);
        geometryline.vertices.push(pt1);
        var materialLine = new THREE.LineBasicMaterial( { color: 0x0000ff,linewidth: 3} );
        var line = new THREE.LineSegments( geometryline, materialLine );
        scene.add( line );
//        objects.push( line );

        geometryline = new THREE.Geometry();
        geometryline.vertices.push(pt1);
        geometryline.vertices.push(pt2);
        materialLine = new THREE.LineBasicMaterial( { color: 0x0000ff,linewidth: 3} );
        line = new THREE.LineSegments( geometryline, materialLine );
        scene.add( line );
//        objects.push( line );

        geometryline = new THREE.Geometry();
        geometryline.vertices.push(pt2);
        geometryline.vertices.push(pt3);
        materialLine = new THREE.LineBasicMaterial( { color: 0x0000ff,linewidth: 3} );
        line = new THREE.LineSegments( geometryline, materialLine );
        scene.add( line );
//        objects.push( line );

        geometryline = new THREE.Geometry();
        geometryline.vertices.push(pt3);
        geometryline.vertices.push(pt0);
        materialLine = new THREE.LineBasicMaterial( { color: 0x0000ff,linewidth: 3} );
        line = new THREE.LineSegments( geometryline, materialLine );
        scene.add( line );
//        objects.push( line );

        geometryline = new THREE.Geometry();
        geometryline.vertices.push(pt0);
        geometryline.vertices.push(pt2);
        materialLine = new THREE.LineBasicMaterial( { color: 0x0000ff,linewidth: 3} );
        line = new THREE.LineSegments( geometryline, materialLine );
        scene.add( line );
//        objects.push( line );

// Textures
        var texture = new THREE.TextureLoader().load( '../textures/cocotte256x256.jpg' );
        texture.repeat.set(0.1, 0.1);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        var material = new THREE.MeshPhongMaterial( {
          map: texture,
          side: THREE.FrontSide,
          flatShading: THREE.SmoothShading
        } );

// Face
        var geometry = new THREE.Geometry();
        geometry.vertices.push( pt0 );
        geometry.vertices.push( pt1 );
        geometry.vertices.push( pt2 );
        var face = new THREE.Face3( 0, 1, 2);
        geometry.faces.push( face );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        // Textures
        var xmin = -200;
        var ymin = -200;
        var xmax = 200;
        var ymax = 200;
        var factor = (xmax - xmin) / 16;// * 256; // / 256 * 32;
        geometry.faceVertexUvs[0] = [];
//        geometry.faceVertexUvs[0].push([
//          new THREE.Vector2((-xmin + pt0.x) / factor, (-ymin + pt0.y) / factor),
//          new THREE.Vector2((-xmin + pt1.x) / factor, (-ymin + pt1.y) / factor),
//          new THREE.Vector2((-xmin + pt2.x) / factor, (-ymin + pt2.y) / factor)
//        ]);
        geometry.faceVertexUvs[0].push([
          new THREE.Vector2(-5, -5),
          new THREE.Vector2(5, -5),
          new THREE.Vector2(5, 5)
        ]);

        // Object
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

        // Second triangle
        geometry = new THREE.Geometry();
        geometry.vertices.push( pt2 );
        geometry.vertices.push( pt3 );
        geometry.vertices.push( pt0 );
        face = new THREE.Face3( 0, 1, 2);
        geometry.faces.push( face );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        // Textures
        geometry.faceVertexUvs[0] = [];
//        geometry.faceVertexUvs[0].push([
//          new THREE.Vector2((-xmin + pt2.x) / factor, (-ymin + pt2.y) / factor),
//          new THREE.Vector2((-xmin + pt3.x) / factor, (-ymin + pt3.y) / factor),
//          new THREE.Vector2((-xmin + pt0.x) / factor, (-ymin + pt0.y) / factor)
//        ]);
        geometry.faceVertexUvs[0].push([
          new THREE.Vector2(5, 5),
          new THREE.Vector2(-5, 5),
          new THREE.Vector2(-5, -5)
        ]);

        // Object
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

// Renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

// Select
        var selectPoints = [];
        var selectLines = [];
        var selectControls = new SelectControls( objects, camera, renderer.domElement );
        selectControls.addEventListener( 'selectPt', function ( event, object ) {
          var pt = event.object;
          if (selectPoints.length === 0){
            // Select
            selectPoints[0] = pt;
            selectPoints[0].material.size = 40;
            selectPoints[0].material.color.r = 1.0;
          } else if (selectPoints[0] === pt) {
            // Deselect
            selectPoints[0].material.color.r = 0.0;
            selectPoints.splice( 0, 1 );
          } else {
            // Got two
            selectPoints[1] = pt;
            selectPoints[1].material.size = 40;
            selectPoints[1].material.color.r = 1.0;
            console.log("AddLine");
            // Do
            var addline = new THREE.Geometry();
            addline.vertices.push(new THREE.Vector3(
              selectPoints[0].geometry.vertices[0].x,
              selectPoints[0].geometry.vertices[0].y,
              selectPoints[0].geometry.vertices[0].z));
            addline.vertices.push(new THREE.Vector3(
              selectPoints[1].geometry.vertices[0].x,
              selectPoints[1].geometry.vertices[0].y,
              selectPoints[1].geometry.vertices[0].z));
            var addMaterialLine = new THREE.LineBasicMaterial( { color: 0xff00ff,linewidth: 6} );
            var line = new THREE.LineSegments( addline, addMaterialLine );
            scene.add( line );
            selectPoints.splice( 0, 1 );
            selectPoints.splice( 0, 1 );
          }
          console.dir(pt);
				}
				);
        selectControls.activate();

// Div
				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> ThreeJS';
				container.appendChild( info );

				stats = new Stats();
				container.appendChild( stats.dom );

// dat.GUI
        var gui = new dat.GUI();
        var params = {
          selectTwo: function () {
            alert('Select two points');
            anim = false;
            selectControls.activate();
          },
          endSelect: function () {
            alert('End Select');
            controls.enabled = true;
            selectControls.deactivate();
          },
          clearSelect: function () {
            controls.enabled = true;
            // Deselect
            for (var i = 0, l = scene.children.length; i < l; i++) {
              if (scene.children[i] instanceof THREE.Points) {
                scene.children[i].material.color.r = 0.0;
                scene.children[i].material.size = 20;
              } else if (scene.children[i] instanceof THREE.LineSegments) {
                scene.children[i].material.linewidth = 3;
                scene.children[i].material.color.r = 0.0;
              }

            }
          },
          anim: function () {
            anim = ! anim;
          }
        };
        gui.add( params, 'selectTwo' );
        gui.add( params, 'endSelect' );
        gui.add( params, 'clearSelect' );
        gui.add( params, 'anim' );
        gui.open();

        //
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			//
			function animate(time) {
				requestAnimationFrame( animate );
        if (anim){
          scene.rotation.y += 0.01;
        }
        render();
				stats.update();
			}

			function render() {
				controls.update();
				renderer.render( scene, camera );
			}
		</script>

	</body>
</html>
